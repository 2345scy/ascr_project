////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			//Z_i is the number of detections for ID i
			index_zi = lookup_n_detection(is_animalID, s, 0, 1, 0, n_IDs, 0);
			index_data_IDmask = lookup_data_IDmask(is_animalID, s, 0, 1, 1,
							0, n_IDs, 0, n_masks);
			index_data_mask = lookup_data_mask(s, 1, n_masks);
			index_data_dist_theta = lookup_data_dist_theta(s, 1, 1, n_traps, n_masks);

			p_toa_ssq = &toa_ssq[index_data_IDmask];

			for(i = 1; i <= n_i; i++){

				Z_i = n_detection(index_zi);
				l_i = Type(0.0);

				index_data_full = lookup_data_full(is_animalID, s, 0, i, 1,
							0, n_IDs_for_datafull, n_traps, 0);

				p_sigma_toa_mask = &sigma_toa_vec_mask[index_data_mask];
				p_kappa_mask = &kappa_vec_mask[index_data_mask];
				p_alpha_mask = &alpha_vec_mask[index_data_mask];
				p_sigma_ss_mask = &sigma_ss_vec_mask[index_data_mask];
				
				p_dx = &dx[index_data_dist_theta];
				p_theta = &theta[index_data_dist_theta];
				p_mu = &mu[index_data_dist_theta];

				//reset p_D_tem
				p_D_tem = &D_tem[0];

				for(m = 1; m <= n_m; m++){

					//since we sum up original likelihood for each mask, so the inital value
					//should be 1 instead of 0
					fw = Type(1.0);

					p_capt_bin = &capt_bin[index_data_full];
					//for fw=f(w_i|x,n;theta)
					for(t = 1; t <= n_t; t++){
						if(is_ss == 0){
							fw *= pow(p_k(m - 1, t - 1), (*p_capt_bin)) * 
								pow((1 - p_k(m - 1, t - 1)), (1 - (*p_capt_bin)));
						} else if(is_ss_het == 0){
							//pow(p_k(), capt_bin()) term could be cancelled out with fy_ss
							fw *= pow((1 - p_k(m - 1, t - 1)), (1 - (*p_capt_bin)));
						}
						p_capt_bin++;
					}
					//cancelled out p_dot from original likelihood: fw /= p_dot(m - 1);

					//the section below for 'fy' will be the same for all kinds of detfn excluding ss
					//make this part a function later
					//for fy=f(y_i|w_i,x,n;theta)
					
					fy_toa_log = Type(0.0);
					fy_bear_log = Type(0.0);
					fy_dist_log = Type(0.0);
					fy_ss_log = Type(0.0);

					//toa
					if(is_toa == 1){
						//"sigma_toa" is not trap extendable nor ID either, so take index_data_full_D as well
						*p_sigma_toa_tem = *p_sigma_toa_full + *p_sigma_toa_mask;
						trans(p_sigma_toa_tem, par_link(14));

						fy_toa_log += (1 - Z_i) * log(sigma_toa_tem) + (-0.5) * (*p_toa_ssq) / pow(sigma_toa_tem, 2);

						p_sigma_toa_mask++;
						p_toa_ssq++;

					}
					


					p_capt_bin = &capt_bin[index_data_full];
					p_capt_bearing = &capt_bearing[index_data_full];
					p_capt_dist = &capt_dist[index_data_full];
					p_capt_ss = &capt_ss[index_data_full];



					p_kappa_full = &kappa_vec_full[index_data_full];
					p_alpha_full = &alpha_vec_full[index_data_full];
					p_sigma_ss_full = &sigma_ss_vec_full[index_data_full];

					for(t = 1; t <= n_t; t++){
						//bearing
						if(is_bearing == 1){
							if(*p_capt_bin > 0){
								*p_kappa_tem = *p_kappa_full + *p_kappa_mask;
								trans(p_kappa_tem, par_link(12));
								fy_bear_log += (kappa_tem * cos(*p_capt_bearing - *p_theta) - 
									log(besselI(kappa_tem, Type(0))));
							}
						}

						//dist
						if(is_dist == 1){
							if(*p_capt_bin > 0){
								*p_alpha_tem = *p_alpha_full + *p_alpha_mask;
								trans(p_alpha_tem, par_link(13));
								fy_dist_log +=  ((-1) * (alpha_tem * (log(*p_dx) - log(alpha_tem)) + lgamma(alpha_tem)) + (alpha_tem - 1) * 
									log(*p_capt_dist) - alpha_tem * (*p_capt_dist) / *p_dx);						
							}
						}

						//ss_origin
						if(is_ss_origin == 1){
							if(*p_capt_bin > 0){
								*p_sigma_ss_tem = *p_sigma_ss_full + *p_sigma_ss_mask;
								trans(p_sigma_ss_tem, par_link(11));
								
								fy_ss_log += dnorm(*p_capt_ss, *p_mu, sigma_ss_tem, true);
							}
						}

						p_capt_bin++;
						p_capt_bearing++;
						p_capt_dist++;
						p_capt_ss++;


						p_kappa_full++;
						p_alpha_full++;
						p_sigma_ss_full++;


						p_mu++;
						p_dx++;
						p_theta++;
					}

					//end of the section for 'fy'

					//for fx=f(x|n;theta)
					//canceled out p_dot & lambda from original likelihood: 
					//fx = D_tem[m-1] * p_dot(m - 1) / lambda_theta = D_tem[m-1];
					//so fx was directly integrated into l_i below


					//we sum up likelihood (not log-likelihood) of each mask 
					l_i += fw * (*p_D_tem) * exp(fy_toa_log + fy_bear_log + fy_dist_log + fy_ss_log);

					p_D_tem++;
					p_sigma_toa_mask++;

					p_kappa_mask++;
					p_alpha_mask++;
					p_sigma_ss_mask++;
					//end for mask m
				}
			  
			  	*pointer_nll -= log(l_i);

				index_zi++;

			  //end for ID i
			}

			//end for if(n_i != 0)
		}